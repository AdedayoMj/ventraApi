{"version":3,"file":"worker.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClFA;AACA;AAEA;AACA;AAGA;AAuDA;AAtDA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1DA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAfA;AAiBA;AACA;AACA;AAAA;AACA;AACA;AACA;AALA;AAOA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AACA;AAAA;AACA;AACA;AACA;AALA;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AAIA;AAEA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA","sources":["webpack://ventrata_api/./node_modules/hono/dist/compose.js","webpack://ventrata_api/./node_modules/hono/dist/context.js","webpack://ventrata_api/./node_modules/hono/dist/hono.js","webpack://ventrata_api/./node_modules/hono/dist/index.js","webpack://ventrata_api/./node_modules/hono/dist/middleware/body-parse/index.js","webpack://ventrata_api/./node_modules/hono/dist/middleware/cors/index.js","webpack://ventrata_api/./node_modules/hono/dist/middleware/pretty-json/index.js","webpack://ventrata_api/./node_modules/hono/dist/request.js","webpack://ventrata_api/./node_modules/hono/dist/router.js","webpack://ventrata_api/./node_modules/hono/dist/router/trie-router/index.js","webpack://ventrata_api/./node_modules/hono/dist/router/trie-router/node.js","webpack://ventrata_api/./node_modules/hono/dist/router/trie-router/router.js","webpack://ventrata_api/./node_modules/hono/dist/utils/body.js","webpack://ventrata_api/./node_modules/hono/dist/utils/url.js","webpack://ventrata_api/./src/app.ts","webpack://ventrata_api/./src/models/model.ts","webpack://ventrata_api/webpack/bootstrap","webpack://ventrata_api/./src/index.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compose = void 0;\nconst context_1 = require(\"./context\");\n// Based on the code in the MIT licensed `koa-compose` package.\nconst compose = (middleware, onError, onNotFound) => {\n    return async (context, next) => {\n        let index = -1;\n        return dispatch(0);\n        async function dispatch(i) {\n            if (i <= index) {\n                return Promise.reject(new Error('next() called multiple times'));\n            }\n            let handler = middleware[i];\n            index = i;\n            if (i === middleware.length && next)\n                handler = next;\n            if (!handler) {\n                if (context instanceof context_1.Context && context.finalized === false && onNotFound) {\n                    context.res = onNotFound(context);\n                }\n                return Promise.resolve(context);\n            }\n            return Promise.resolve(handler(context, () => dispatch(i + 1)))\n                .then(async (res) => {\n                // If handler return Response like `return c.text('foo')`\n                if (res && context instanceof context_1.Context) {\n                    context.res = res;\n                }\n                return context;\n            })\n                .catch((err) => {\n                if (context instanceof context_1.Context && onError) {\n                    if (err instanceof Error) {\n                        context.res = onError(err, context);\n                    }\n                    return context;\n                }\n                else {\n                    throw err;\n                }\n            });\n        }\n    };\n};\nexports.compose = compose;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Context = void 0;\nconst url_1 = require(\"./utils/url\");\nclass Context {\n    constructor(req, env = undefined, event = undefined, notFoundHandler = () => new Response()) {\n        this._status = 200;\n        this._pretty = false;\n        this._prettySpace = 2;\n        this.req = req;\n        if (env) {\n            this.env = env;\n        }\n        this.event = event;\n        this.notFoundHandler = notFoundHandler;\n        this.finalized = false;\n    }\n    get res() {\n        return (this._res || (this._res = new Response()));\n    }\n    set res(_res) {\n        this._res = _res;\n        this.finalized = true;\n    }\n    header(name, value) {\n        this._headers || (this._headers = {});\n        this._headers[name] = value;\n        if (this.finalized) {\n            this.res.headers.set(name, value);\n        }\n    }\n    status(status) {\n        this._status = status;\n    }\n    set(key, value) {\n        this._map || (this._map = {});\n        this._map[key] = value;\n    }\n    get(key) {\n        if (!this._map) {\n            return undefined;\n        }\n        return this._map[key];\n    }\n    pretty(prettyJSON, space = 2) {\n        this._pretty = prettyJSON;\n        this._prettySpace = space;\n    }\n    newResponse(data, status, headers = {}) {\n        const _headers = { ...this._headers, ...headers };\n        if (this._res) {\n            this._res.headers.forEach((v, k) => {\n                _headers[k] = v;\n            });\n        }\n        return new Response(data, {\n            status: status || this._status || 200,\n            headers: _headers,\n        });\n    }\n    body(data, status = this._status, headers = {}) {\n        return this.newResponse(data, status, headers);\n    }\n    text(text, status = this._status, headers = {}) {\n        headers['Content-Type'] || (headers['Content-Type'] = 'text/plain; charset=UTF-8');\n        return this.body(text, status, headers);\n    }\n    json(object, status = this._status, headers = {}) {\n        const body = this._pretty\n            ? JSON.stringify(object, null, this._prettySpace)\n            : JSON.stringify(object);\n        headers['Content-Type'] || (headers['Content-Type'] = 'application/json; charset=UTF-8');\n        return this.body(body, status, headers);\n    }\n    html(html, status = this._status, headers = {}) {\n        headers['Content-Type'] || (headers['Content-Type'] = 'text/html; charset=UTF-8');\n        return this.body(html, status, headers);\n    }\n    redirect(location, status = 302) {\n        if (!(0, url_1.isAbsoluteURL)(location)) {\n            const url = new URL(this.req.url);\n            url.pathname = location;\n            location = url.toString();\n        }\n        return this.newResponse(null, status, {\n            Location: location,\n        });\n    }\n    notFound() {\n        return this.notFoundHandler(this);\n    }\n}\nexports.Context = Context;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Hono = void 0;\nconst compose_1 = require(\"./compose\");\nconst context_1 = require(\"./context\");\nconst request_1 = require(\"./request\");\nconst router_1 = require(\"./router\");\nconst trie_router_1 = require(\"./router/trie-router\"); // Default Router\nconst url_1 = require(\"./utils/url\");\nconst methods = ['get', 'post', 'put', 'delete', 'head', 'options', 'patch'];\nfunction defineDynamicClass() {\n    return class {\n    };\n}\nclass Hono extends defineDynamicClass() {\n    constructor(init = {}) {\n        super();\n        this.router = new trie_router_1.TrieRouter();\n        this.strict = true; // strict routing - default is true\n        this._tempPath = '';\n        this.path = '/';\n        this.routes = [];\n        this.notFoundHandler = (c) => {\n            const message = '404 Not Found';\n            return c.text(message, 404);\n        };\n        this.errorHandler = (err, c) => {\n            console.error(`${err.stack || err.message}`);\n            const message = 'Internal Server Error';\n            return c.text(message, 500);\n        };\n        (0, request_1.extendRequestPrototype)(); // FIXME: should be executed at a better timing\n        const allMethods = [...methods, router_1.METHOD_NAME_ALL_LOWERCASE];\n        allMethods.map((method) => {\n            this[method] = (args1, ...args) => {\n                if (typeof args1 === 'string') {\n                    this.path = args1;\n                }\n                else {\n                    this.addRoute(method, this.path, args1);\n                }\n                args.map((handler) => {\n                    if (typeof handler !== 'string') {\n                        this.addRoute(method, this.path, handler);\n                    }\n                });\n                return this;\n            };\n        });\n        Object.assign(this, init);\n    }\n    route(path, app) {\n        this._tempPath = path;\n        if (app) {\n            app.routes.map((r) => {\n                this.addRoute(r.method, r.path, r.handler);\n            });\n            this._tempPath = '';\n        }\n        return this;\n    }\n    use(arg1, ...handlers) {\n        if (typeof arg1 === 'string') {\n            this.path = arg1;\n        }\n        else {\n            handlers.unshift(arg1);\n        }\n        handlers.map((handler) => {\n            this.addRoute(router_1.METHOD_NAME_ALL, this.path, handler);\n        });\n        return this;\n    }\n    onError(handler) {\n        this.errorHandler = handler;\n        return this;\n    }\n    notFound(handler) {\n        this.notFoundHandler = handler;\n        return this;\n    }\n    addRoute(method, path, handler) {\n        method = method.toUpperCase();\n        if (this._tempPath) {\n            path = (0, url_1.mergePath)(this._tempPath, path);\n        }\n        this.router.add(method, path, handler);\n        const r = { path: path, method: method, handler: handler };\n        this.routes.push(r);\n    }\n    matchRoute(method, path) {\n        return this.router.match(method, path);\n    }\n    async dispatch(request, event, env) {\n        const path = (0, url_1.getPathFromURL)(request.url, this.strict);\n        const method = request.method;\n        const result = this.matchRoute(method, path);\n        request.paramData = result?.params;\n        const handlers = result ? result.handlers : [this.notFoundHandler];\n        const c = new context_1.Context(request, env, event, this.notFoundHandler);\n        const composed = (0, compose_1.compose)(handlers, this.errorHandler, this.notFoundHandler);\n        let context;\n        try {\n            context = await composed(c);\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                return this.errorHandler(err, c);\n            }\n            throw err;\n        }\n        return context.res;\n    }\n    async handleEvent(event) {\n        return this.dispatch(event.request, event);\n    }\n    async fetch(request, env, event) {\n        return this.dispatch(request, event, env);\n    }\n    request(input, requestInit) {\n        const req = input instanceof Request ? input : new Request(input, requestInit);\n        return this.dispatch(req);\n    }\n    fire() {\n        addEventListener('fetch', (event) => {\n            event.respondWith(this.handleEvent(event));\n        });\n    }\n}\nexports.Hono = Hono;\n","\"use strict\";\n// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path=\"./request.ts\" /> Import \"declare global\" for the Request interface.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Context = exports.Hono = void 0;\nvar hono_1 = require(\"./hono\");\nObject.defineProperty(exports, \"Hono\", { enumerable: true, get: function () { return hono_1.Hono; } });\nvar context_1 = require(\"./context\");\nObject.defineProperty(exports, \"Context\", { enumerable: true, get: function () { return context_1.Context; } });\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bodyParse = void 0;\nconst body_1 = require(\"../../utils/body\");\nconst bodyParse = () => {\n    return async (ctx, next) => {\n        ctx.req.parsedBody = await (0, body_1.parseBody)(ctx.req);\n        await next();\n    };\n};\nexports.bodyParse = bodyParse;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.cors = void 0;\nconst cors = (options) => {\n    const defaults = {\n        origin: '*',\n        allowMethods: ['GET', 'HEAD', 'PUT', 'POST', 'DELETE', 'PATCH'],\n        allowHeaders: [],\n        exposeHeaders: [],\n    };\n    const opts = {\n        ...defaults,\n        ...options,\n    };\n    return async (c, next) => {\n        await next();\n        function set(key, value) {\n            c.res.headers.append(key, value);\n        }\n        set('Access-Control-Allow-Origin', opts.origin);\n        // Suppose the server sends a response with an Access-Control-Allow-Origin value with an explicit origin (rather than the \"*\" wildcard).\n        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin\n        if (opts.origin !== '*') {\n            set('Vary', 'Origin');\n        }\n        if (opts.credentials) {\n            set('Access-Control-Allow-Credentials', 'true');\n        }\n        if (opts.exposeHeaders?.length) {\n            set('Access-Control-Expose-Headers', opts.exposeHeaders.join(','));\n        }\n        if (c.req.method === 'OPTIONS') {\n            // Preflight\n            if (opts.maxAge != null) {\n                set('Access-Control-Max-Age', opts.maxAge.toString());\n            }\n            if (opts.allowMethods?.length) {\n                set('Access-Control-Allow-Methods', opts.allowMethods.join(','));\n            }\n            let headers = opts.allowHeaders;\n            if (!headers?.length) {\n                const requestHeaders = c.req.headers.get('Access-Control-Request-Headers');\n                if (requestHeaders) {\n                    headers = requestHeaders.split(/\\s*,\\s*/);\n                }\n            }\n            if (headers?.length) {\n                set('Access-Control-Allow-Headers', headers.join(','));\n                set('Vary', 'Access-Control-Request-Headers');\n            }\n            c.res.headers.delete('Content-Length');\n            c.res.headers.delete('Content-Type');\n            c.res = new Response(null, {\n                headers: c.res.headers,\n                status: 204,\n                statusText: c.res.statusText,\n            });\n        }\n    };\n};\nexports.cors = cors;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.prettyJSON = void 0;\nconst prettyJSON = (options = { space: 2 }) => {\n    return async (c, next) => {\n        const pretty = c.req.query('pretty') || c.req.query('pretty') === '' ? true : false;\n        c.pretty(pretty, options.space);\n        await next();\n    };\n};\nexports.prettyJSON = prettyJSON;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extendRequestPrototype = void 0;\nfunction extendRequestPrototype() {\n    if (!!Request.prototype.param) {\n        // already extended\n        return;\n    }\n    Request.prototype.param = function (key) {\n        if (this.paramData) {\n            if (key) {\n                return this.paramData[key];\n            }\n            else {\n                return this.paramData;\n            }\n        }\n        return null;\n    };\n    Request.prototype.header = function (name) {\n        if (name) {\n            return this.headers.get(name);\n        }\n        else {\n            const result = {};\n            for (const [key, value] of this.headers) {\n                result[key] = value;\n            }\n            return result;\n        }\n    };\n    Request.prototype.query = function (key) {\n        const url = new URL(this.url);\n        if (key) {\n            return url.searchParams.get(key);\n        }\n        else {\n            const result = {};\n            for (const key of url.searchParams.keys()) {\n                result[key] = url.searchParams.get(key) || '';\n            }\n            return result;\n        }\n    };\n    Request.prototype.queries = function (key) {\n        const url = new URL(this.url);\n        if (key) {\n            return url.searchParams.getAll(key);\n        }\n        else {\n            const result = {};\n            for (const key of url.searchParams.keys()) {\n                result[key] = url.searchParams.getAll(key);\n            }\n            return result;\n        }\n    };\n}\nexports.extendRequestPrototype = extendRequestPrototype;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.METHOD_NAME_ALL_LOWERCASE = exports.METHOD_NAME_ALL = void 0;\nexports.METHOD_NAME_ALL = 'ALL';\nexports.METHOD_NAME_ALL_LOWERCASE = 'all';\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TrieRouter = void 0;\nvar router_1 = require(\"./router\");\nObject.defineProperty(exports, \"TrieRouter\", { enumerable: true, get: function () { return router_1.TrieRouter; } });\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Node = void 0;\nconst router_1 = require(\"../../router\");\nconst url_1 = require(\"../../utils/url\");\nfunction findParam(node, name) {\n    for (let i = 0, len = node.patterns.length; i < len; i++) {\n        if (typeof node.patterns[i] === 'object' && node.patterns[i][1] === name) {\n            return true;\n        }\n    }\n    const nodes = Object.values(node.children);\n    for (let i = 0, len = nodes.length; i < len; i++) {\n        if (findParam(nodes[i], name)) {\n            return true;\n        }\n    }\n    return false;\n}\nclass Node {\n    constructor(method, handler, children) {\n        this.order = 0;\n        this.children = children || {};\n        this.methods = [];\n        if (method && handler) {\n            const m = {};\n            m[method] = { handler: handler, score: 0, name: this.name };\n            this.methods = [m];\n        }\n        this.patterns = [];\n        this.handlerSetCache = {};\n    }\n    insert(method, path, handler) {\n        this.name = `${method} ${path}`;\n        this.order = ++this.order;\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let curNode = this;\n        const parts = (0, url_1.splitPath)(path);\n        const parentPatterns = [];\n        const errorMessage = (name) => {\n            return `Duplicate param name, use another name instead of '${name}' - ${method} ${path} <--- '${name}'`;\n        };\n        for (let i = 0, len = parts.length; i < len; i++) {\n            const p = parts[i];\n            if (Object.keys(curNode.children).includes(p)) {\n                parentPatterns.push(...curNode.patterns);\n                curNode = curNode.children[p];\n                continue;\n            }\n            curNode.children[p] = new Node();\n            const pattern = (0, url_1.getPattern)(p);\n            if (pattern) {\n                if (typeof pattern === 'object') {\n                    for (let j = 0, len = parentPatterns.length; j < len; j++) {\n                        if (typeof parentPatterns[j] === 'object' && parentPatterns[j][1] === pattern[1]) {\n                            throw new Error(errorMessage(pattern[1]));\n                        }\n                    }\n                    if (Object.values(curNode.children).some((n) => findParam(n, pattern[1]))) {\n                        throw new Error(errorMessage(pattern[1]));\n                    }\n                }\n                curNode.patterns.push(pattern);\n                parentPatterns.push(...curNode.patterns);\n            }\n            parentPatterns.push(...curNode.patterns);\n            curNode = curNode.children[p];\n        }\n        let score = 1;\n        if (path === '*') {\n            score = score + this.order * 0.01;\n        }\n        else {\n            score = parts.length + this.order * 0.01;\n        }\n        if (!curNode.methods.length) {\n            curNode.methods = [];\n        }\n        const m = {};\n        const handlerSet = { handler: handler, name: this.name, score: score };\n        m[method] = handlerSet;\n        curNode.methods.push(m);\n        return curNode;\n    }\n    getHandlerSets(node, method, wildcard) {\n        var _a, _b;\n        return ((_a = node.handlerSetCache)[_b = `${method}:${wildcard ? '1' : '0'}`] || (_a[_b] = (() => {\n            const handlerSets = [];\n            node.methods.map((m) => {\n                const handlerSet = m[method] || m[router_1.METHOD_NAME_ALL];\n                if (handlerSet !== undefined) {\n                    const hs = { ...handlerSet };\n                    if (wildcard) {\n                        hs.score = handlerSet.score - 1;\n                    }\n                    handlerSets.push(hs);\n                    return;\n                }\n            });\n            return handlerSets;\n        })()));\n    }\n    search(method, path) {\n        const handlerSets = [];\n        const params = {};\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const curNode = this;\n        let curNodes = [curNode];\n        const parts = (0, url_1.splitPath)(path);\n        for (let i = 0, len = parts.length; i < len; i++) {\n            const part = parts[i];\n            const isLast = i === len - 1;\n            const tempNodes = [];\n            for (let j = 0, len2 = curNodes.length; j < len2; j++) {\n                const node = curNodes[j];\n                for (let k = 0, len3 = node.patterns.length; k < len3; k++) {\n                    const pattern = node.patterns[k];\n                    // Wildcard\n                    // '/hello/*/foo' => match /hello/bar/foo\n                    if (pattern === '*') {\n                        const astNode = node.children['*'];\n                        if (astNode) {\n                            handlerSets.push(...this.getHandlerSets(astNode, method));\n                            tempNodes.push(astNode);\n                        }\n                        continue;\n                    }\n                    if (part === '')\n                        continue;\n                    // Named match\n                    // `/posts/:id` => match /posts/123\n                    const [key, name, matcher] = pattern;\n                    if (matcher === true || (matcher instanceof RegExp && matcher.test(part))) {\n                        if (typeof key === 'string') {\n                            if (isLast === true) {\n                                handlerSets.push(...this.getHandlerSets(node.children[key], method));\n                            }\n                            tempNodes.push(node.children[key]);\n                        }\n                        if (typeof name === 'string') {\n                            params[name] = part;\n                        }\n                    }\n                }\n                const nextNode = node.children[part];\n                if (nextNode) {\n                    if (isLast === true) {\n                        // '/hello/*' => match '/hello'\n                        if (nextNode.children['*']) {\n                            handlerSets.push(...this.getHandlerSets(nextNode.children['*'], method, true));\n                        }\n                        handlerSets.push(...this.getHandlerSets(nextNode, method));\n                    }\n                    tempNodes.push(nextNode);\n                }\n            }\n            curNodes = tempNodes;\n        }\n        if (handlerSets.length <= 0)\n            return null;\n        const handlers = handlerSets\n            .sort((a, b) => {\n            return a.score - b.score;\n        })\n            .map((s) => {\n            return s.handler;\n        });\n        return { handlers, params };\n    }\n}\nexports.Node = Node;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TrieRouter = void 0;\nconst node_1 = require(\"./node\");\nclass TrieRouter {\n    constructor() {\n        this.node = new node_1.Node();\n    }\n    add(method, path, handler) {\n        this.node.insert(method, path, handler);\n    }\n    match(method, path) {\n        return this.node.search(method, path);\n    }\n}\nexports.TrieRouter = TrieRouter;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseBody = void 0;\nconst parseBody = async (r) => {\n    const contentType = r.headers.get('Content-Type') || '';\n    if (contentType.includes('application/json')) {\n        return await r.json();\n    }\n    else if (contentType.includes('application/text')) {\n        return await r.text();\n    }\n    else if (contentType.startsWith('text')) {\n        return await r.text();\n    }\n    else if (contentType.includes('form')) {\n        const form = {};\n        const data = [...(await r.formData())].reduce((acc, cur) => {\n            acc[cur[0]] = cur[1];\n            return acc;\n        }, form);\n        return data;\n    }\n    return r.arrayBuffer();\n};\nexports.parseBody = parseBody;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergePath = exports.isAbsoluteURL = exports.getPathFromURL = exports.getPattern = exports.splitPath = void 0;\nconst URL_REGEXP = /^https?:\\/\\/[a-zA-Z0-9\\-\\.:]+(\\/?[^?#]*)/;\nconst splitPath = (path) => {\n    const paths = path.split(/\\//); // faster than path.split('/')\n    if (paths[0] === '') {\n        paths.shift();\n    }\n    return paths;\n};\nexports.splitPath = splitPath;\nconst patternCache = {};\nconst getPattern = (label) => {\n    // *            => wildcard\n    // :id{[0-9]+}  => ([0-9]+)\n    // :id          => (.+)\n    //const name = ''\n    if (label === '*') {\n        return '*';\n    }\n    const match = label.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/);\n    if (match) {\n        if (!patternCache[label]) {\n            if (match[2]) {\n                patternCache[label] = [label, match[1], new RegExp('^' + match[2] + '$')];\n            }\n            else {\n                patternCache[label] = [label, match[1], true];\n            }\n        }\n        return patternCache[label];\n    }\n    return null;\n};\nexports.getPattern = getPattern;\nconst getPathFromURL = (url, strict = true) => {\n    const queryIndex = url.indexOf('?');\n    const result = url.substring(url.indexOf('/', 8), queryIndex === -1 ? url.length : queryIndex);\n    // if strict routing is false => `/hello/hey/` and `/hello/hey` are treated the same\n    // default is true\n    if (strict === false && result.endsWith('/')) {\n        return result.slice(0, -1);\n    }\n    return result;\n};\nexports.getPathFromURL = getPathFromURL;\nconst isAbsoluteURL = (url) => {\n    const match = url.match(URL_REGEXP);\n    if (match) {\n        return true;\n    }\n    return false;\n};\nexports.isAbsoluteURL = isAbsoluteURL;\nconst mergePath = (...paths) => {\n    let p = '';\n    let endsWithSlash = false;\n    for (let path of paths) {\n        /* ['/hey/','/say'] => ['/hey', '/say'] */\n        if (p.endsWith('/')) {\n            p = p.slice(0, -1);\n            endsWithSlash = true;\n        }\n        /* ['/hey','say'] => ['/hey', '/say'] */\n        if (!path.startsWith('/')) {\n            path = `/${path}`;\n        }\n        /* ['/hey/', '/'] => `/hey/` */\n        if (path === '/' && endsWithSlash) {\n            p = `${p}/`;\n        }\n        else if (path !== '/') {\n            p = `${p}${path}`;\n        }\n        /* ['/', '/'] => `/` */\n        if (path === '/' && p === '') {\n            p = '/';\n        }\n    }\n    return p;\n};\nexports.mergePath = mergePath;\n","import { Hono } from 'hono'\nimport * as model from './models/model'\nimport { Bindings } from './bindings'\nimport { bodyParse } from 'hono/body-parse'\nimport { cors } from 'hono/cors'\n\n\nconst api = new Hono<Bindings>()\napi.use('/products/*', cors(), bodyParse())\n\napi.get('/', (c:any) => {\n return c.json({ message: 'Hello' })\n})\n\napi.get('/products', async (c:any) => {\n const products = await model.getProducts(c.env.VENTRATA)\n return c.json({ products: products, ok: true })\n})\n\napi.post('/products', async (c:any) => {\n\n const param = c.req.parsedBody\n if(!param) return  c.json({ error: \"Field required\", ok: false }, 422)\n const newPost = await model.createProduct(c.env.VENTRATA, param)\n if (!newPost) {\n   return c.json({ error: 'Can not create new Product', ok: false }, 422)\n }\n return c.json({ post: newPost, ok: true }, 201)\n})\n\napi.get('/products/:id', async (c:any) => {\n const id = c.req.param('id')\n const post = await model.getProduct(c.env.VENTRATA, id)\n if (!post) {\n   return c.json({ error: 'Not Found', ok: false }, 404)\n }\n return c.json({ post: post, ok: true })\n})\n\napi.put('/products/:id', async (c:any) => {\n const id = c.req.param('id')\n const post = await model.getProduct(c.env.VENTRATA, id)\n if (!post) {\n   // 204 No Content\n   return new Response(null, { status: 204 })\n }\n const param = c.req.parsedBody\n const success = await model.updateProduct(c.env.VENTRATA, id, param)\n return c.json({ ok: success })\n})\n\napi.delete('/products/:id', async (c:any) => {\n const id = c.req.param('id')\n const post = await model.getProduct(c.env.VENTRATA, id)\n if (!post) {\n   // 204 No Content\n   return new Response(null, { status: 204 })\n }\n const success = await model.deletePost(c.env.VENTRATA, id)\n return c.json({ ok: success })\n})\n\nexport { api } \n","import { Param, Product } from '../types';\n\nconst PREFIX = 'v1:post:'\n\nconst generateID = (key: string) => {\n  return `${PREFIX}${key}`\n}\n\n\nexport const getProducts = async (KV: KVNamespace): Promise<Product[]> => {\n  const list = await KV.list({ prefix: PREFIX })\n  const keys = list.keys\n  const products: Product[] = []\n\n  const len = keys.length\n  for (let i = 0; i < len; i++) {\n    const value = await KV.get(keys[i].name)\n    if (value) {\n      const product: Product = JSON.parse(value)\n      products.push(product)\n    }\n  }\n\n  return products\n}\n\nexport const getProduct = async (KV: KVNamespace, id: string): Promise<Product | undefined> => {\n  const value = await KV.get(generateID(id))\n  if (!value) return\n  const post: Product = JSON.parse(value)\n  return post\n}\n\nexport const createProduct = async (KV: KVNamespace, param: Param): Promise<Product | undefined> => {\n  if (!(param && param.name && param.options && param.availableCurrencies && param.defaultCurrency)) return\n  const id = crypto.randomUUID()\n  const newPost: Product = { id: id, name: param.name, options: param.options, defaultCurrency: param.defaultCurrency, availableCurrencies: param.availableCurrencies }\n  await KV.put(generateID(id), JSON.stringify(newPost))\n  return newPost\n}\n\nexport const updateProduct = async (KV: KVNamespace, id: string, param: Param): Promise<boolean> => {\n  if (!(param && param.name && param.options)) return false\n  const post = await getProduct(KV, id)\n  if (!post) return false\n  post.name = param.name\n  post.options = param.options\n  await KV.put(generateID(id), JSON.stringify(post))\n  return true\n}\n\nexport const deletePost = async (KV: KVNamespace, id: string): Promise<boolean> => {\n  const post = await getProduct(KV, id)\n  if (!post) return false\n  await KV.delete(generateID(id))\n  return true\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { Hono } from 'hono'\n// import { basicAuth } from 'hono/basic-auth'\nimport { prettyJSON } from 'hono/pretty-json'\nimport { api } from './app'\nimport { Bindings } from './bindings'\n\n\nconst app = new Hono()\n\napp.get('/', (c) => c.text('Booking API'))\n\napp.notFound((c) => c.json({ message: 'Not Found', ok: false }, 404))\n\nconst middleware = new Hono<Bindings>()\nmiddleware.use('*', prettyJSON())\nmiddleware.use('/products/*', async (_c, next) => {\n  \n  \n  await next()\n})\n\napp.route('/api', middleware)\napp.route('/api', api)\n\nexport default app"],"names":[],"sourceRoot":""}