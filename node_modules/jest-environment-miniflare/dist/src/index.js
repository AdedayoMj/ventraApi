var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// packages/jest-environment-miniflare/src/index.ts
__export(exports, {
  default: () => MiniflareEnvironment
});
var import_vm = __toModule(require("vm"));
var import_fake_timers = __toModule(require("@jest/fake-timers"));
var import_cache = __toModule(require("@miniflare/cache"));
var import_core = __toModule(require("@miniflare/core"));
var import_durable_objects = __toModule(require("@miniflare/durable-objects"));
var import_html_rewriter = __toModule(require("@miniflare/html-rewriter"));
var import_kv = __toModule(require("@miniflare/kv"));
var import_runner_vm = __toModule(require("@miniflare/runner-vm"));
var import_shared = __toModule(require("@miniflare/shared"));
var import_sites = __toModule(require("@miniflare/sites"));
var import_web_sockets = __toModule(require("@miniflare/web-sockets"));
var import_jest_mock = __toModule(require("jest-mock"));
var import_jest_util = __toModule(require("jest-util"));

// packages/jest-environment-miniflare/src/storage.ts
var import_assert = __toModule(require("assert"));
var import_storage_memory = __toModule(require("@miniflare/storage-memory"));
var StackedMemoryStorage = class extends import_storage_memory.MemoryStorage {
  stack = [];
  push() {
    this.stack.push(this.map);
    this.map = new Map(this.map);
  }
  pop() {
    this.map = this.stack.pop() ?? new Map();
  }
};
var StackedMemoryStorageFactory = class {
  storages = new Map();
  storage(namespace, persist) {
    (0, import_assert.default)(!persist);
    let storage = this.storages.get(namespace);
    if (storage)
      return storage;
    this.storages.set(namespace, storage = new StackedMemoryStorage());
    return storage;
  }
  push() {
    for (const storage of this.storages.values())
      storage.push();
  }
  pop() {
    for (const storage of this.storages.values())
      storage.pop();
  }
};

// packages/jest-environment-miniflare/src/index.ts
var PLUGINS = {
  CorePlugin: import_core.CorePlugin,
  KVPlugin: import_kv.KVPlugin,
  DurableObjectsPlugin: import_durable_objects.DurableObjectsPlugin,
  CachePlugin: import_cache.CachePlugin,
  SitesPlugin: import_sites.SitesPlugin,
  HTMLRewriterPlugin: import_html_rewriter.HTMLRewriterPlugin,
  WebSocketPlugin: import_web_sockets.WebSocketPlugin,
  BindingsPlugin: import_core.BindingsPlugin
};
var log = new import_shared.NoOpLog();
var MiniflareEnvironment = class {
  config;
  context;
  fakeTimers;
  fakeTimersModern;
  global;
  moduleMocker;
  customExportConditions = ["worker", "browser"];
  storageFactory = new StackedMemoryStorageFactory();
  scriptRunner;
  constructor(config, _context) {
    if ("projectConfig" in config)
      config = config.projectConfig;
    this.config = config;
    this.context = import_vm.default.createContext({});
    (0, import_runner_vm.defineHasInstances)(this.context);
    this.scriptRunner = new import_runner_vm.VMScriptRunner(this.context);
    const global = this.global = import_vm.default.runInContext("this", this.context);
    global.global = global;
    global.self = global;
    global.clearInterval = clearInterval;
    global.clearTimeout = clearTimeout;
    global.setInterval = setInterval;
    global.setTimeout = setTimeout;
    global.Buffer = Buffer;
    (0, import_jest_util.installCommonGlobals)(global, this.config.globals);
    if ("customExportConditions" in this.config.testEnvironmentOptions) {
      const { customExportConditions } = this.config.testEnvironmentOptions;
      if (Array.isArray(customExportConditions) && customExportConditions.every((item) => typeof item === "string")) {
        this.customExportConditions = customExportConditions;
      } else {
        throw new Error("Custom export conditions specified but they are not an array of strings");
      }
    }
    this.moduleMocker = new import_jest_mock.ModuleMocker(global);
    const timerIdToRef = (id) => ({
      id,
      ref() {
        return this;
      },
      unref() {
        return this;
      }
    });
    const timerRefToId = (timer) => timer && timer.id || void 0;
    this.fakeTimers = new import_fake_timers.LegacyFakeTimers({
      config: this.config,
      global,
      moduleMocker: this.moduleMocker,
      timerConfig: { idToRef: timerIdToRef, refToId: timerRefToId }
    });
    this.fakeTimersModern = new import_fake_timers.ModernFakeTimers({
      config: this.config,
      global
    });
  }
  async setup() {
    const global = this.global;
    const mf = new import_core.MiniflareCore(PLUGINS, {
      log,
      storageFactory: this.storageFactory,
      scriptRunner: this.scriptRunner,
      scriptRunForModuleExports: true
    }, {
      wranglerConfigPath: true,
      packagePath: true,
      envPathDefaultFallback: true,
      ...this.config.testEnvironmentOptions,
      globals: {
        ...this.config.testEnvironmentOptions?.globals,
        console: global.console,
        setTimeout: global.setTimeout,
        setInterval: global.setInterval,
        clearTimeout: global.clearTimeout,
        clearInterval: global.clearInterval
      },
      watch: false,
      kvPersist: false,
      cachePersist: false,
      durableObjectsPersist: false,
      globalAsyncIO: true,
      globalTimers: true,
      globalRandom: true
    });
    const mfGlobalScope = await mf.getGlobalScope();
    mfGlobalScope.global = global;
    mfGlobalScope.self = global;
    Object.assign(global, mfGlobalScope);
    const bindings = await mf.getBindings();
    global.getMiniflareBindings = () => bindings;
    global.getMiniflareDurableObjectStorage = async (id) => {
      const plugin = (await mf.getPlugins()).DurableObjectsPlugin;
      const storage = mf.getPluginStorage("DurableObjectsPlugin");
      const state = await plugin.getObject(storage, id);
      return state.storage;
    };
  }
  async teardown() {
    this.fakeTimers?.dispose();
    this.fakeTimersModern?.dispose();
    this.context = null;
    this.fakeTimers = null;
    this.fakeTimersModern = null;
  }
  exportConditions() {
    return this.customExportConditions;
  }
  getVmContext() {
    return this.context;
  }
  handleTestEvent(event, _state) {
    if (event.name === "run_describe_start" || event.name === "test_start") {
      this.storageFactory.push();
    }
    if (event.name === "run_describe_finish" || event.name === "test_done") {
      this.storageFactory.pop();
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=index.js.map
